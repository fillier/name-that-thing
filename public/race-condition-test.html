<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Race Condition Test - Name That Thing</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        .test-section {
            margin: 20px 0;
            padding: 20px;
            border: 1px solid #ddd;
            border-radius: 8px;
        }
        .results {
            margin: 10px 0;
            padding: 10px;
            background: #f5f5f5;
            border-radius: 4px;
        }
        .success { background: #d4edda; }
        .error { background: #f8d7da; }
        .warning { background: #fff3cd; }
        .progress {
            margin: 10px 0;
            padding: 10px;
            background: #e3f2fd;
            border-radius: 4px;
        }
        button {
            padding: 10px 20px;
            margin: 5px;
            border: none;
            border-radius: 4px;
            background: #007bff;
            color: white;
            cursor: pointer;
        }
        button:disabled {
            background: #6c757d;
            cursor: not-allowed;
        }
        input[type="file"] {
            margin: 10px 0;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            width: 100%;
        }
        .log {
            height: 300px;
            overflow-y: auto;
            background: #f8f9fa;
            border: 1px solid #ddd;
            padding: 10px;
            font-family: monospace;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <h1>Race Condition Test - Canvas Processing</h1>
    <p>This test helps verify that the image processing improvements are working correctly and reduce race condition failures.</p>

    <div class="test-section">
        <h2>Multi-Image Processing Test</h2>
        <p>Upload multiple images to test sequential vs concurrent processing:</p>
        <input type="file" id="imageFiles" multiple accept="image/*">
        <br>
        <button onclick="testSequentialProcessing()">Test Sequential Processing (Fixed)</button>
        <button onclick="testConcurrentProcessing()">Test Concurrent Processing (May Fail)</button>
        <button onclick="clearResults()">Clear Results</button>
        
        <div class="progress" id="progress" style="display: none;">
            Processing: <span id="progressText">0/0</span>
        </div>
        
        <div class="results" id="results"></div>
    </div>

    <div class="test-section">
        <h2>Processing Log</h2>
        <div class="log" id="log"></div>
    </div>

    <script>
        let testResults = [];
        
        function log(message) {
            const logDiv = document.getElementById('log');
            const timestamp = new Date().toLocaleTimeString();
            logDiv.innerHTML += `[${timestamp}] ${message}\n`;
            logDiv.scrollTop = logDiv.scrollHeight;
            console.log(message);
        }

        function clearResults() {
            document.getElementById('results').innerHTML = '';
            document.getElementById('log').innerHTML = '';
            document.getElementById('progress').style.display = 'none';
            testResults = [];
        }

        function updateProgress(current, total) {
            const progressDiv = document.getElementById('progress');
            const progressText = document.getElementById('progressText');
            
            if (total > 0) {
                progressDiv.style.display = 'block';
                progressText.textContent = `${current}/${total}`;
            } else {
                progressDiv.style.display = 'none';
            }
        }

        function displayResults(title, results) {
            const resultsDiv = document.getElementById('results');
            const successful = results.filter(r => r.success);
            const failed = results.filter(r => !r.success);
            
            const summary = `
                <h3>${title}</h3>
                <div class="success">‚úÖ Successful: ${successful.length}</div>
                <div class="error">‚ùå Failed: ${failed.length}</div>
                <div class="warning">‚ö†Ô∏è Success Rate: ${(successful.length / results.length * 100).toFixed(1)}%</div>
            `;
            
            resultsDiv.innerHTML += summary;
            
            if (failed.length > 0) {
                failed.forEach(result => {
                    log(`‚ùå FAILED: ${result.fileName} - ${result.error}`);
                });
            }
        }

        async function testSequentialProcessing() {
            const files = document.getElementById('imageFiles').files;
            if (files.length === 0) {
                alert('Please select some images first');
                return;
            }

            log(`üîÑ Starting sequential processing test with ${files.length} images...`);
            
            const results = [];
            updateProgress(0, files.length);
            
            // Process files one at a time (our fix)
            for (let i = 0; i < files.length; i++) {
                const file = files[i];
                log(`üì∑ Processing ${file.name} (${i + 1}/${files.length})`);
                
                try {
                    const result = await processImage(file);
                    results.push({ ...result, fileName: file.name });
                    updateProgress(i + 1, files.length);
                    
                    // Small delay like our fix
                    if (i < files.length - 1) {
                        await new Promise(resolve => setTimeout(resolve, 150));
                    }
                } catch (error) {
                    results.push({ 
                        success: false, 
                        error: error.message, 
                        fileName: file.name 
                    });
                }
            }
            
            displayResults('Sequential Processing Results', results);
            log(`‚úÖ Sequential processing complete`);
        }

        async function testConcurrentProcessing() {
            const files = document.getElementById('imageFiles').files;
            if (files.length === 0) {
                alert('Please select some images first');
                return;
            }

            log(`üîÑ Starting concurrent processing test with ${files.length} images...`);
            
            // Process all files at once (old problematic way)
            const promises = Array.from(files).map(async (file, index) => {
                log(`üì∑ Starting concurrent processing of ${file.name}`);
                try {
                    const result = await processImage(file);
                    return { ...result, fileName: file.name };
                } catch (error) {
                    return { 
                        success: false, 
                        error: error.message, 
                        fileName: file.name 
                    };
                }
            });
            
            const results = await Promise.all(promises);
            displayResults('Concurrent Processing Results', results);
            log(`‚úÖ Concurrent processing complete`);
        }

        async function processImage(file) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                img.onload = async () => {
                    try {
                        canvas.width = Math.min(img.width, 800);
                        canvas.height = Math.min(img.height, 600);
                        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                        
                        // Test creating multiple pixelation levels like our app does
                        const levels = [32, 16, 8, 0]; // Our fixed order
                        const blobs = {};
                        
                        for (let i = 0; i < levels.length; i++) {
                            const pixelSize = levels[i];
                            const levelKey = `level${i + 1}`;
                            
                            try {
                                if (pixelSize === 0) {
                                    // Original image
                                    blobs[levelKey] = await new Promise((res, rej) => {
                                        const timeout = setTimeout(() => rej(new Error('Timeout')), 10000);
                                        canvas.toBlob((blob) => {
                                            clearTimeout(timeout);
                                            if (blob && blob.size > 0) {
                                                res(blob);
                                            } else {
                                                rej(new Error(`Failed to create ${levelKey}`));
                                            }
                                        }, 'image/jpeg', 0.9);
                                    });
                                } else {
                                    // Pixelated version
                                    blobs[levelKey] = await createPixelatedBlob(canvas, pixelSize);
                                }
                                
                                log(`‚úÖ Created ${levelKey} for ${file.name} (${blobs[levelKey].size} bytes)`);
                            } catch (error) {
                                log(`‚ùå Failed to create ${levelKey} for ${file.name}: ${error.message}`);
                                throw error;
                            }
                        }
                        
                        resolve({
                            success: true,
                            levels: blobs,
                            dimensions: { width: canvas.width, height: canvas.height }
                        });
                        
                    } catch (error) {
                        reject(error);
                    }
                };
                
                img.onerror = () => reject(new Error('Failed to load image'));
                img.src = URL.createObjectURL(file);
            });
        }

        async function createPixelatedBlob(canvas, pixelSize) {
            return new Promise((resolve, reject) => {
                const timeout = setTimeout(() => reject(new Error('Pixelation timeout')), 15000);
                
                try {
                    const ctx = canvas.getContext('2d');
                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    const data = imageData.data;
                    
                    // Pixelation algorithm (simplified version of our utils)
                    for (let y = 0; y < canvas.height; y += pixelSize) {
                        for (let x = 0; x < canvas.width; x += pixelSize) {
                            let r = 0, g = 0, b = 0, a = 0, count = 0;
                            
                            for (let dy = 0; dy < pixelSize && y + dy < canvas.height; dy++) {
                                for (let dx = 0; dx < pixelSize && x + dx < canvas.width; dx++) {
                                    const idx = ((y + dy) * canvas.width + (x + dx)) * 4;
                                    r += data[idx];
                                    g += data[idx + 1];
                                    b += data[idx + 2];
                                    a += data[idx + 3];
                                    count++;
                                }
                            }
                            
                            if (count > 0) {
                                r = Math.round(r / count);
                                g = Math.round(g / count);
                                b = Math.round(b / count);
                                a = Math.round(a / count);
                                
                                for (let dy = 0; dy < pixelSize && y + dy < canvas.height; dy++) {
                                    for (let dx = 0; dx < pixelSize && x + dx < canvas.width; dx++) {
                                        const idx = ((y + dy) * canvas.width + (x + dx)) * 4;
                                        data[idx] = r;
                                        data[idx + 1] = g;
                                        data[idx + 2] = b;
                                        data[idx + 3] = a;
                                    }
                                }
                            }
                        }
                    }
                    
                    ctx.putImageData(imageData, 0, 0);
                    
                    canvas.toBlob((blob) => {
                        clearTimeout(timeout);
                        if (blob && blob.size > 0) {
                            resolve(blob);
                        } else {
                            reject(new Error('Failed to create pixelated blob'));
                        }
                    }, 'image/jpeg', 0.9);
                    
                } catch (error) {
                    clearTimeout(timeout);
                    reject(error);
                }
            });
        }

        // Initialize
        log('üöÄ Race condition test page loaded');
        log('üìã Instructions:');
        log('1. Select multiple image files (3-5 recommended)');
        log('2. Test sequential processing (should work reliably)');
        log('3. Test concurrent processing (may show race condition failures)');
        log('4. Compare success rates between the two approaches');
    </script>
</body>
</html>
